% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getVarValues.R
\name{getVarValues}
\alias{getVarValues}
\title{[~] Parse arguments of a function and return approriate values for selected variable}
\usage{
getVarValues(VAR, DATA, CALL = match.call(definition =
  sys.function(sys.parent()), call = sys.call(sys.parent())))
}
\arguments{
\item{VAR}{A name of a variable (with or without quotes).}

\item{DATA}{A name of a data frame (with or without quotes).}

\item{CALL}{(\code{\link[=call-class]{Call}}) to be parsed. Default is
call to parent function.}
}
\value{
A vector. If possible, return \code{DATA[,VAR]}.
Otherwise return \code{VAR}.
}
\description{
Parse dataframe \code{DATA}, variable \code{VAR} and a call
\code{CALL} of a function and return approriate values of the
\code{VAR}. \cr If possible, return \code{DATA[,"VAR"]} \cr
Otherwise return \code{VAR}.
}
\examples{
# --------------------------------------------------------------------
# [NOT IMPLEMENTED YET] if length(VAR) == 1, it must be interpreted as a string.



# EXAMPLE 1 *****************************************************************

# Data
df  <- mtcars[,c("cyl","gear")]

#  Function, that uses `getVarValues`:
f1 <- function(data, v1, v2) { getVarValues(v1, data) }

# Returns values of `df$cyl`:
f1(df, cyl)
##  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4

f1(df, "cyl")
##  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4

cyl <- "gear"        # !!! Still values of `df$cyl`, not `df$gear`:
f1(df, cyl)
##  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4

# Returns values of `df$gear`:
f1(df, gear)
## [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4


# Returns values of vector `a`, as there is no variable `df$a`:
a = "cyl"
f1(df, a)
## [1] "cyl"

var <- c("My", "variable", "var")
f1(df, var)
## [1] "My"   "variable"   "var"


# EXAMPLE 2 *****************************************************************
# A Data frame
   df <- data.frame(A = "Values_A_(DATA.FRAME)",
                    E = "Values_E_(DATA.FRAME)", stringsAsFactors = FALSE)

# Vectors
   A <- "Values of the vector 'A'"
   B <- "Values of the vector 'B'"


# A call object `CALL`:

fun  <- function(data, gr, ID) match.call()
CALL <- fun(df, A, B)
CALL
## fun(data = df, gr = A, ID = B)


# Outputs of `getVarValues` -------------------------------------------------

getVarValues(VAR = gr, DATA = df, CALL = CALL)
## [1] Values A (DATA.FRAME)

getVarValues(gr, df, CALL)
## [1] Values A (DATA.FRAME)

getVarValues(A, df, CALL)
## [1] "Values of the vector 'A'"

getVarValues(B, df, CALL)
## [1] "Values of the vector 'B'"

# UNEXPECTED results -----------------------------------------------------------------------

\donttest{
\dontrun{

 getVarValues(ID, df, CALL) # ??? `ID` found only in function's `fun` definition.
 ## NULL

 getVarValues(G, df, CALL) # ERROR, as variable G does not exist.
 ##  Error in eval(expr, envir, enclos) : object 'G' not found

 getVarValues(F, df, CALL) # F is a special variable: F = FALSE
 ##  FALSE

 getVarValues(c, df, CALL) # c() is a function.
 ## function (..., recursive = FALSE)  .Primitive("c")
}}
}
\author{
Vilmantas Gegzna
}

