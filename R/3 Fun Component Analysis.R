# Apskaičiuoti Komponenų amplitudes matricų daugybos būdu ------------------------------
#
#' [!] Calculate component amplitudes (a.k.a scores) by matrix multiplication
#'
#' @details
#'  \deqn{k_amp = y * k_sp * inv(k_sp' * k_sp)}
#'
#'  formula is taken  and adapted from [1]
#' @references [1] M. Brydegaard et al. IEEE Photonics J 2011:3(3);406-21.
#'
#' @param y - matrix with experimental spectra
#' @param k_sp - matrix with components' spectra
#' @param label - label for components for plotting ???
#'
#' @return k_amp - amplitudes of the components
#' @examples
#' # e.g.:
#'     y = Object
#'     k_sp = loadings
#'
#' getScores(y, k_sp)
#'
#' @export
#'
#' @import hyperSpec
#'
getScores <- function(y, k_sp, xLabel = "Component", yLabel = "Amplitude")
{
    y2 <- hy2mat(y)
    k_sp2 <- hy2mat(k_sp)

    if (dim(y2)[2] == dim(k_sp2)[2])   k_sp2 <- t(k_sp2)

    k_amp <- y2 %*% (k_sp2 %*% solve(crossprod(k_sp2)))

    if (class(y) == "hyperSpec"){
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Komponentų amplitudes (išrikiuotas) paverčiam į "HyperSpec"" objektą

        k_amp <- decomposition(y, k_amp,
                               label.wavelength = "Komponentai",
                               label.spc = "Amplitudė, a.u.")
        # Suteikiam pavadinimus
        if("kNames" %in% colnames(k_sp)){
            kNames <- gsub("max: ","k_", k_sp$kNames)
        }else {kNames <- paste0("Nr", 1:min(dim(k_sp2)))}

        colnames(k_amp$spc) <- kNames

        labels(k_amp,".wavelength") <- xLabel
        labels(k_amp,"spc")         <- yLabel
    }
    # ======================================================================
    return(k_amp)
}

# ****** Komp: informacijos dimensija ******* -----------------------------------

#' Calculate information dimension of a matix.
#'
#' The function calculates a measure, called "information dimension".
#'
#'
#' @param  Matrix - data matrix (rows = observations, columns = variables)
#'
#' @return A list with fields:
#'  \itemize{
#'  \item{$dim }{- information dimension ,rounded towards positive infinitive}
#'  \item{$exactDim  }{- information dimension (fractional, not rounded)}
#'  \item{$explained  }{- a vector of eigenvalues, normalized by sum of eigenvalues,
#'   which can be used to determine the importance of (principal) components}
#'  \item{$eigenvalues }{- a vector of eigenvalues}
#'  \item{$n.comp }{- avector with integers from 1 to length(eigenvalues)}
#' }
#'
#' @references [1]	R. Cangelosi and A. Goriely, Component retention in principal
#'       component analysis with application to cDNA microarray data.
#'       Biol Direct, 2, 2 (2007), \url{http://dx.doi.org/10.1186/1745-6150-2-2}
#'
#' @note
#' Prieš pradedant vykdyti operaciją, svarbus žingsnis pasirinkti tinkamą
#' normavimo buda. To nepadarius gausime klaidingą atsakymą.
#' y=sp_normuok(y,x,'1',495);
#'
#' Taip pat labai svarbus ir triukšmo lygis. Didėjant triukšmui atitinkamai
#' padidinamas maksimalus dimensijų skaičius.
#'
#'
#' @note
#' eigenvalues - Tikrines reiksmes / Singular values
#' pk - tikimybines dimensiju vertes, skirtos entropijos ivertinimui.
#' explain = pk;
#'
#' @seealso InfoDim_plot
#' @export
#'
#' @examples
#'  my_matrix <- matrix(rexp(200, rate=.1), ncol=20)
#'
#'  my_result <- InfoDim(my_matrix)
#'
#'  # Investigate the result
#'  str(my_result)
#'  my_result$exactDim
#'  my_result$dim
#'
#'  #Plot
#'  my_plot <- InfoDim_plot(my_result)
#'  my_plot
#'
InfoDim <- function(Matrix)
{

    eigenval   <- svd(Matrix)$d
    explain    <- eigenval / sum(eigenval);
    exact_dim   <- prod(sapply(explain,function(x){x^-x}));
    dim         <- ceiling(exact_dim);    # % Round towards infinitive

    output <- list(      dim   = dim,
                         exactDim   = exact_dim,
                         explained   = explain,
                         eigenvalues = eigenval,
                         n.comp      = 1:length(explain))
    return(output)
}


#' Plot the result of \code{\link{InfoDim}}
#'
#' @param Object - an object (list), generated by function \code{\link{InfoDim}}
#' @param n.comp.SHOW - number of components to show, default is 20. This
#' number can be corrected if either vector of eigenvalues is smaller than 20
#' or information dimension is higher than 15.
#'
#' @return A plot of class "trellis" which helps to estimate the number of
#'  nenessary components
#'
#' @export
#'
#' @examples
#'  my_matrix <- matrix(rexp(200, rate=.1), ncol=20)
#'
#'  my_result <- InfoDim(my_matrix)
#'
#'  # Investigate the result
#'  str(my_result)
#'  my_result$exactDim
#'  my_result$dim
#'
#'  #Plot
#'  my_plot <- InfoDim_plot(my_result)
#'  my_plot
#'
#' @importFrom lattice xyplot
#'
InfoDim_plot <- function(Object, n.comp.SHOW = 20, selected = NULL){

    # Adjust n.comp.SHOW
    At_least <- max(n.comp.SHOW,  Object$dim+5)
    But_no_more_than <- length(Object$eigenval)
    n.comp.SHOW = min(At_least, But_no_more_than)

    # Plot
    PlotExplained <- lattice::xyplot(
        log10(100*explained[1:n.comp.SHOW]) ~ n.comp[1:n.comp.SHOW],
        data = Object,
        type = c("b","g"),
        cex = 1.2,
        xlim = c(0,n.comp.SHOW+0.5),
        xlab = "Number of components",
        ylab = "Explained, log %",
        abline = list(v = c(Object$exactDim,selected), lty = "dotted", col = c("red","green4")),
        key=list(space="top",
                 lines=list(col=c("#0080ff","red","green4"), lty=c(1,2,2), lwd=1),
                 text =list(c("Norm. eigenvalues","Info.dimension","Selected")),
                 columns = 3
        )
    )
    return(PlotExplained)
}


# GaussAmp ------------------------------------------------------------------
#
# [!] Funkcija GaussAmp skirta vienai ar kelioms gausinėms kreivėms braižyti.
#
# *PARAMETRAI:*
# x  - x ašies reikšmių vektorius;
# xc - vektorius su centro padėtimis;
# w  - vektorius su vidutiniais kvadratiniais nuokrypiais, sigma;
# A  - vektorius su amplitudėmis;
# y0 - kreivės pagrindo aukštis virš x ašies (konstanta, vienoda visoms
#      kreivėms).
#
# *IŠVESTIS:*
# k_sp - matrica su kreivių reikšmėmis ties atitinkamais x.
#
# *SINTAKSĖ:*
#        GaussAmp; # Funkcijos demonstracija
# k_sp = GaussAmp(x,xc,w,A)
# k_sp = GaussAmp(x,xc,w,A,y0)
#
#
# Autorius Ignas Čiplys       2014-10-28
# Modifikavo Vilmantas Gėgžna 2014-12-03

#' Generate Gausian curve(s) (GaussAmp)
#'
#' @param x vector of x values
#' @param xc vector with centers of Gaussian curves
#' @param w  vector with parameter w, which determines the width of Gaussian curves
#' @param A  vector with Amplitudes of Gaussian curves
#' @param y0 vector with offsets on y axis
#'
#' @note The number of curves is determined by maximal length of any of 4
#' Gausian curve parameters' (xc, w, A, y0) vector. Other parameters are
#' recycled as shown in example 2 (parameter "A")
#'
#' @return y values of Gaussian curve
#' @export
#'
#' @examples
#' # Example 1
#' x <- seq(-9.9, 10, 0.2)
#' y <- GaussAmp(x)
#'
#' plot(x,y, type = "l", col = "green3"); grid()
#'
#' # Example 2
#'
#' require(hyperSpec)
#'
#' # Make 7 lines
#' y <- GaussAmp(x, xc = 1:7,A = c(1,2))
#'
#' dim(y)
#' ##[1]   7 100
#'
#' Obj <- new("hyperSpec",spc = y,    wavelength = x,
#'          label = list (spc = "y", .wavelength = "x"))
#' plot(Obj, col = 1:nrow(Obj)); grid()
#'
GaussAmp <- function(x, xc = 0, w = 1, A = 1, y0 = 0){
    P <- max(length(xc),length(w),length(A),length(y0))

    xc <- rep_len(xc, P)
    w  <- rep_len(w,  P)
    A  <- rep_len(A,  P)
    y0 <- rep_len(y0, P)
    # Prealocate y
    y = matrix(NA ,P,length(x))
    # Generate the curves
    for (i in 1:P){ y[i,] <- y0[i]+A[i]*exp(-(((x-xc[i])^2)/(2*w[i]^2)))}

    ## Output
    return(y)
}


# uniPeak -----------------------------------------------------------------
#' @name uniPeak
#' @aliases uniPeak
#' @aliases unipeak
#'
#' @title [!] Keep only the highest positive peak
#'
#' Keep only the highest positive peak
#'
#' @param y vector
#'
#' @return Modified y
#' @export
#'
#' @examples
#' #  Example 1 ------------------------------------------------------------------------
#'
#' x     <- seq(-10,20,.1)
#' y0    <- GaussAmp(x,xc=0, A=1) + GaussAmp(x,xc=10, A=2) -.5
#' y0NEW <- uniPeak(y0)
#'
#' # Plot the results
#' par(mfrow = c(1,1))
#' plot( x, y0,    type = "l", lty = 3,
#'         main = "'uniPeak' keeps positive part \n of highest peak only" );
#' lines(x, y0NEW, type = "l", lty = 1, lwd = 3);
#' legend("topleft", legend = c("Before","After"), lty = c(3,1))
#'
#'
#' #  Example 2 ------------------------------------------------------------------------
#'
#' x  = seq(-10,20,.1)
#' y1 = (sin(x/4) + GaussAmp(x))
#' y2 = (2*sin(x) + sin(x/5) + GaussAmp(x, xc = 5))
#' y  = rbind(y1,y2)
#'
#' yNEW <- apply(y,1,uniPeak)
#'
#' par(mfrow = c(3,1))
#'
#' # plot 1
#' matplot(x, t(y), type = "l", lty = 3,
#'         main = "A - Initial curves");
#' abline(h=0)
#'
#' # plot 2
#' matplot(x,yNEW, type = "l", lty = 1,lwd = 3,
#'         main = "B - Only the highest positive\n peaks per curve");
#' abline(h=0)
#'
#' # plot 3: both plots together
#' matplot(x, t(y), type = "l", lty = 3, main = "A and B together");
#' matlines(x,yNEW, type = "l", lty = 1,lwd = 3);
#' abline(h=0)
#'
uniPeak <- function(y)
{     y <- as.vector(y)
i <- seq_along(y)
len <- length(y)

di <- c(diff(as.numeric(y<=0)),0)
imax <- which.max(y)

# Indices of part to keep
iBegin <- which(di==-1 & i<(i[imax]))
iBegin <- tail(iBegin, n=1)[1]

iEnd  <- which(di==1 & i>(i[imax]))[1]
# Corrections of Indices
if (is.na(iBegin)) iBegin <- 1 else iBegin <- iBegin + 1
if (is.na(iEnd))     iEnd <- len
# New y
yNEW <- rep_len(0, len)
yNEW[iBegin:iEnd] <- y[iBegin:iEnd]
return(yNEW)
}

#' @rdname uniPeak
#' @export
unipeak <- function(y){uniPeak(y)}


# Sort component spectra =======================================================================
#' [!] Sort component spectra (a.k.a. Loadings) by possition of top peak
#'
#' [!] = [INCOMPLETE DESCRIPTION] Sort component spectra (a.k.a. Loadings) by possition of top peak and
#' return
#'
#' @param loadings - matrix of loadings (components).
#' @param Sp - spectra (object of class \code{\link{hyperSpec}}) which will
#' be used to convert sorted loadings into \code{\link{hyperSpec}} object.
#' More information at \code{\link{hyperSpec::decomposition}}
#' @param PCA - if TRUE, some components are flipped. ... Set to TRUE if PCA loadings are used.
#'               Default \code{PCA = FALSE}
#'
#' @return Either matrix (if \code{Sp} is not provided) or hyperSpec object with sorted loadings.
#' In case of hyperSpec object, 3 additional columns (PeakAt, order.of.rows, kNames) are added.
#' @export
#'
#' @import hyperSpec
#' @examples
#'
#' sortLoadings(loadings)        # returns a matrix
#'
#' sortLoadings(loadings,Sp)     # returns a hyperSpec object
#'
sortLoadings <- function(loadings,Sp = NULL,PCA = FALSE){

    if (PCA & !is.null(Sp)){
        ScoresTMP  <- getScores(hy2mat(Sp), loadings)
        # ----------------------------------------------------------------------
        # Apverčiama, jei amplitudžių vidurkis neigiamas
        meanSign     <- function(x){sign(mean(x))}
        signCoefs    <- apply(ScoresTMP, MARGIN= 2, meanSign)
        loadings     <- sweep(loadings,  MARGIN= 1, signCoefs,`*`)
        # Normuojama
        maxSpInt     <- apply(loadings, MARGIN= 1, max)
        PCAvarimax2  <- sweep(loadings, MARGIN= 1, maxSpInt,`/`)

        # ======================================================================
    }
    # Rikiuojam iš eilės pagal matrcos eilučių maksimumo (y_max) vietą x ašy
    index.of.max <- apply(loadings, 1, which.max)
    OrderOfRows <- order(index.of.max)

    # Viršūnių padėtis
    index.of.max <- index.of.max[OrderOfRows]

    # Matrix with Sorted components
    loadingsSorted <- loadings[OrderOfRows,]

    if (is.null(Sp)) {return(loadingsSorted)} else {

        # Komponentus (išrikiuotas) paverčiam į "HyperSpec"" objektą
        loadingsOUT <- decomposition(Sp, loadingsSorted,
                                     scores = FALSE,
                                     label.spc = "Komp. spektras",
                                     retain.columns = F)


        # Suteikiam pavadinimus komponantams
        PeakAt    <- make.unique(paste0(round(wl(loadingsOUT)[index.of.max]),
                                        "nm"),"_")

        # WARNING is needed, if variables with names are already present
        loadingsOUT$PeakAt       <- PeakAt
        loadingsOUT$kNames       <- paste0("max: ", PeakAt)
        loadingsOUT$order.of.rows<- OrderOfRows

        labels(loadingsOUT,'spc') <- labels(Sp,'spc')

        return(loadingsOUT)
    }


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # # Komponentų amplitudes (išrikiuotas) paverčiam į "HyperSpec"" objektą
    # scores <- decomposition(Object, t(coef(NMF_data))[,OrderOfRows],
    #                            label.wavelength = "Komponentai",
    #                            label.spc        = "Amplitudė, a.u.")
    # colnames(scores$spc) <- paste0("k_", PeakAt)
    # ======================================================================
    #
    # # Print names of components
    # tbl_virsunes <- data.frame(Nr = 1:length(PeakAt), Padetis = PeakAt)
    # pander(t(tbl_virsunes), caption = "Komponento auksščiausios viršūnės padėtis")
    #
    # kNames    <- loadings$kNames
}
