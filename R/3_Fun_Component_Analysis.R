# Apskaičiuoti Komponenų amplitudes matricų daugybos būdu ------------------------------
#
#' [!] Calculate component amplitudes (a.k.a. scores) by matrix multiplication
#'
#' [!] Calculate component amplitudes (a.k.a. scores) by matrix multiplication
#'
#' @details
#'  \deqn{scores = sp * loadings * inv(loadings' * loadings)}
#'
#'  formula is taken  and adapted from [1]
#' @references [1] M. Brydegaard et al. IEEE Photonics J 2011:3(3);406-21.
#'
#' @param sp - matrix with experimental spectra
#' @param loadings - matrix with components' spectra
#' @param xLabel - label for loadings for plotting ???
#' @param yLabel
#'
#' @return scores - amplitudes of the components
#' @examples
#' # e.g.:
#'     sp = Object
#'     loadings = loadings
#'
#' getScores(sp, loadings)
#'
#' @export
#'
#' @import hyperSpec
#'
getScores <- function(sp, loadings, xLabel = "Component", yLabel = "Amplitude")
{
    y2 <- hy2mat(sp)
    loadings2 <- hy2mat(loadings)

    if (dim(y2)[2] == dim(loadings2)[2])   loadings2 <- t(loadings2)

    scores <- y2 %*% (loadings2 %*% solve(crossprod(loadings2)))

    if (class(sp) == "hyperSpec"){
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Komponentų amplitudes (išrikiuotas) paverčiam į "HyperSpec"" objektą

        scores <- decomposition(sp, scores,
                               label.wavelength = "Komponentai",
                               label.spc = "Amplitudė, a.u.")
        # Suteikiam pavadinimus
        if("kNames" %in% colnames(loadings)){
            kNames <- gsub("max: ","k_", loadings$kNames)
        }else {kNames <- paste0("Nr", 1:min(dim(loadings2)))}

        colnames(scores$spc) <- kNames

        labels(scores,".wavelength") <- xLabel
        labels(scores,"spc")         <- yLabel
    }
    # ======================================================================
    return(scores)
}

# ****** Komp: informacijos dimensija ******* -----------------------------------

#' Calculate information dimension of a matix.
#'
#' The function calculates a measure, called "information dimension".
#'
#'
#' @param  Matrix - data matrix (rows = observations, columns = variables)
#'
#' @return A list with fields:
#'  \itemize{
#'  \item{$dim }{- information dimension ,rounded towards positive infinitive}
#'  \item{$exactDim  }{- information dimension (fractional, not rounded)}
#'  \item{$explained  }{- a vector of eigenvalues, normalized by sum of eigenvalues,
#'   which can be used to determine the importance of (principal) components}
#'  \item{$eigenvalues }{- a vector of eigenvalues}
#'  \item{$n.comp }{- avector with integers from 1 to length(eigenvalues)}
#' }
#'
#' @references [1]	R. Cangelosi and A. Goriely, Component retention in principal
#'       component analysis with application to cDNA microarray data.
#'       Biol Direct, 2, 2 (2007), \url{http://dx.doi.org/10.1186/1745-6150-2-2}
#'
#' @note
#' Prieš pradedant vykdyti operaciją, svarbus žingsnis pasirinkti tinkamą
#' normavimo buda. To nepadarius gausime klaidingą atsakymą. \cr
#' sp = sp_normuok(sp,x,'1',495);
#'
#' Taip pat labai svarbus ir triukšmo lygis. Didėjant triukšmui atitinkamai
#' padidinamas maksimalus dimensijų skaičius.
#'
#'
#' @note
#' eigenvalues - Tikrines reiksmes / Singular values
#' pk - tikimybines dimensiju vertes, skirtos entropijos ivertinimui.
#' explain = pk;
#'
#' @seealso InfoDim_plot
#' @export
#'
#' @examples
#'  my_matrix <- matrix(rexp(200, rate=.1), ncol=20)
#'
#'  my_result <- InfoDim(my_matrix)
#'
#'  # Investigate the result
#'  str(my_result)
#'  my_result$exactDim
#'  my_result$dim
#'
#'  #Plot
#'  my_plot <- InfoDim_plot(my_result)
#'  my_plot
#'
InfoDim <- function(Matrix)
{

    eigenval   <- svd(Matrix)$d
    explain    <- eigenval / sum(eigenval);
    exact_dim   <- prod(sapply(explain,function(x){x^-x}));
    dim         <- ceiling(exact_dim);    # % Round towards infinitive

    output <- list(      dim   = dim,
                         exactDim   = exact_dim,
                         explained   = explain,
                         eigenvalues = eigenval,
                         n.comp      = 1:length(explain))
    return(output)
}


#' [! ]Plot the result of \code{\link{InfoDim}}
#'
#'
#' @param Object - an object (list), generated by function \code{\link{InfoDim}}
#'
#' @param n.comp.SHOW - number of components to show, default is 20. This
#' number can be corrected if either vector of eigenvalues is smaller than 20
#' or information dimension is higher than 15.
#'
#' @param selected - number of components sellected
#'        (will be plotted as a separate vertical line).
#'
#' @param Title - ...
#'
#'
#' @return A plot of class "trellis" which helps to estimate the number of
#'  nenessary components.
#'
#' @export
#'
#' @examples
#'  my_matrix <- matrix(rexp(200, rate=.1), ncol=20)
#'
#'  my_result <- InfoDim(my_matrix)
#'
#'  # Investigate the result
#'  str(my_result)
#'  my_result$exactDim
#'  my_result$dim
#'
#'  #Plot
#'  my_plot <- InfoDim_plot(my_result)
#'  my_plot
#'
#' @note http://www.originlab.com/doc%5Cen/Tutorial/images/Principal_Component_Analysis/Pca_scree_plot.png
#'
InfoDim_plot <- function(Object, n.comp.SHOW = 20, selected = NULL,
                         Title = "Scree Plot"){

    # Adjust n.comp.SHOW
    At_least <- max(n.comp.SHOW,  Object$dim+5)
    But_no_more_than <- length(Object$eigenval)
    n.comp.SHOW = min(At_least, But_no_more_than)
#     x.step  <- floor(n.comp.SHOW/5)
#     x.ticks <- seq(x.step,n.comp.SHOW,x.step)

    # Plot
    PlotExplained <- lattice::xyplot(
        100*explained[1:n.comp.SHOW] ~ n.comp[1:n.comp.SHOW],
        scales = list(y = list(log = 10)#,
                      # x = list(at = x.ticks)
                      ),
        yscale.components = latticeExtra::yscale.components.log10ticks,
        # xscale.components = xscale.components.subticks(),
        main = Title,
        data = Object,
        type = c("b","g"),
        cex = 1.2,
        xlim = c(0,n.comp.SHOW+0.5),
        xlab = "Number of components",
        ylab = "Percentage of variance explained",
        abline = list(v = c(Object$exactDim,selected),
                      lty = "dotted",
                      col = c("red","green4")),
        key=list(corner=c(.95, .95),
                 lines=list(col=c("#0080ff","red","green4"), lty=c(1,2,2), lwd=1),
                 text =list(c("Percentage explained",
                              paste("Information dimension =",round(Object$exactDim,1)),
                              paste("Selected =",selected))
                            )
        )
    )
    return(PlotExplained)
}


# GaussAmp ------------------------------------------------------------------
#
# [!] Funkcija GaussAmp skirta vienai ar kelioms gausinėms kreivėms braižyti.
#
# *PARAMETRAI:*
# x  - x ašies reikšmių vektorius;
# xc - vektorius su centro padėtimis;
# w  - vektorius su vidutiniais kvadratiniais nuokrypiais, sigma;
# A  - vektorius su amplitudėmis;
# y0 - kreivės pagrindo aukštis virš x ašies (konstanta, vienoda visoms
#      kreivėms).
#
# *IŠVESTIS:*
# loadings - matrica su kreivių reikšmėmis ties atitinkamais x.
#
# *SINTAKSĖ:*
#        GaussAmp; # Funkcijos demonstracija
# loadings = GaussAmp(x,xc,w,A)
# loadings = GaussAmp(x,xc,w,A,y0)
#
#
# Autorius Ignas Čiplys       2014-10-28
# Modifikavo Vilmantas Gėgžna 2014-12-03

#' Generate Gausian curve(s) (GaussAmp)
#'
#' @param x vector of x values
#' @param xc vector with centers of Gaussian curves
#' @param w  vector with parameter w, which determines the width of Gaussian curves
#' @param A  vector with Amplitudes of Gaussian curves
#' @param y0 vector with offsets on y axis
#'
#' @note The number of curves is determined by maximal length of any of 4
#' Gausian curve parameters' (xc, w, A, y0) vector. Other parameters are
#' recycled as shown in example 2 (parameter "A")
#'
#' @return y values of Gaussian curve
#' @export
#'
#' @examples
#' # Example 1
#' x <- seq(-9.9, 10, 0.2)
#' y <- GaussAmp(x)
#'
#' plot(x,y, type = "l", col = "green3"); grid()
#'
#' # Example 2
#'
#' require(hyperSpec)
#'
#' # Make 7 lines
#' y <- GaussAmp(x, xc = 1:7,A = c(1,2))
#'
#' dim(y)
#' ##[1]   7 100
#'
#' Obj <- new("hyperSpec",spc = y,    wavelength = x,
#'          label = list (spc = "y", .wavelength = "x"))
#' plot(Obj, col = 1:nrow(Obj)); grid()
#'
GaussAmp <- function(x, xc = 0, w = 1, A = 1, y0 = 0){
    P <- max(length(xc),length(w),length(A),length(y0))

    xc <- rep_len(xc, P)
    w  <- rep_len(w,  P)
    A  <- rep_len(A,  P)
    y0 <- rep_len(y0, P)
    # Prealocate y
    y = matrix(NA ,P,length(x))
    # Generate the curves
    for (i in 1:P){ y[i,] <- y0[i]+A[i]*exp(-(((x-xc[i])^2)/(2*w[i]^2)))}

    ## Output
    return(y)
}


# uniPeak -----------------------------------------------------------------
#' @name uniPeak
#' @aliases uniPeak
#' @aliases unipeak
#'
#' @title [!] Keep only the highest positive peak
#'
#' Keep only the highest positive peak
#'
#' @param y vector
#'
#' @return Modified y
#' @export
#'
#' @examples
#' #  Example 1 ------------------------------------------------------------------------
#'
#' x     <- seq(-10,20,.1)
#' y0    <- GaussAmp(x,xc=0, A=1) + GaussAmp(x,xc=10, A=2) -.5
#' y0NEW <- uniPeak(y0)
#'
#' # Plot the results
#' par(mfrow = c(1,1))
#' plot( x, y0,    type = "l", lty = 3,
#'         main = "'uniPeak' keeps positive part \n of highest peak only" );
#' lines(x, y0NEW, type = "l", lty = 1, lwd = 3);
#' legend("topleft", legend = c("Before","After"), lty = c(3,1))
#'
#'
#' #  Example 2 ------------------------------------------------------------------------
#'
#' x  = seq(-10,20,.1)
#' y1 = (sin(x/4) + GaussAmp(x))
#' y2 = (2*sin(x) + sin(x/5) + GaussAmp(x, xc = 5))
#' y  = rbind(y1,y2)
#'
#' yNEW <- apply(y,1,uniPeak)
#'
#' par(mfrow = c(3,1))
#'
#' # plot 1
#' matplot(x, t(y), type = "l", lty = 3,
#'         main = "A - Initial curves");
#' abline(h=0)
#'
#' # plot 2
#' matplot(x,yNEW, type = "l", lty = 1,lwd = 3,
#'         main = "B - Only the highest positive\n peaks per curve");
#' abline(h=0)
#'
#' # plot 3: both plots together
#' matplot(x, t(y), type = "l", lty = 3, main = "A and B together");
#' matlines(x,yNEW, type = "l", lty = 1,lwd = 3);
#' abline(h=0)
#'
uniPeak <- function(y)  {

    y   <- as.vector(y)
    i   <- seq_along(y)
    len <- length(y)

    di   <- c(diff(as.numeric(y<=0)),0)
    imax <- which.max(y)

    # Indices of part to keep
    iBegin <- which(di==-1 & i<(i[imax]))
    iBegin <- tail(iBegin, n=1)[1]

    iEnd  <- which(di==1 & i>(i[imax]))[1]
    # Corrections of Indices
    if (is.na(iBegin)) iBegin <- 1 else iBegin <- iBegin + 1
    if (is.na(iEnd))     iEnd <- len
    # New y
    yNEW <- rep_len(0, len)
    yNEW[iBegin:iEnd] <- y[iBegin:iEnd]
    return(yNEW)
}

#' @rdname uniPeak
#' @export
unipeak <- function(y){uniPeak(y)}


# Sort component spectra =======================================================================
#' [!] Sort component spectra (a.k.a. loadings) by possition of top peak
#'
#' @description [!] = [INCOMPLETE DESCRIPTION] \cr
#'
#'  Sort component spectra (a.k.a. loadings) by
#'  possition of top peak and do additional tasks:
#'  \enumerate {
#'
#'      \item {1. }{If \code{sp} is provided, convert resulting matrix to corresponding
#'          \code{\link[=hyperSpec-class]{hyperSpec}} object by using function
#'          \code{\link[hyperSpec]{decomposition}}.}
#'
#'
#'      \item {2. }{If \code{PCA = TRUE} and \code{sp} is provided, flips component's spectrum
#'          if mean of its scores is negative: (\code{sign(mean(Scores_of_component_i)) < 0})
#'          \code{loadings} and \code{sp} are used to calculate the scores.}
#'  }
#'
#' @template loadings
#'
#' @template sp
#'
#' @param PCA - if TRUE, some components are flipped. ... Set to TRUE
#' if PCA loadings are used. Default \code{PCA = FALSE}
#'
#' @param sort - flag to indicate if returned componenst must be sorted.
#'       If \code{FALSE}, only additional tasks are performed.
#'       Default is \code{TRUE}.
#'
#' @return Either matrix (if \code{sp} is not provided) or
#' hyperSpec object with sorted loadings.
#' In case of hyperSpec object, 3 additional columns
#' (PeakAt, order.of.rows, kNames) are added.
#'
#' @note spectra (object of class \code{\link[=hyperSpec-class]{hyperSpec}})
#'          which will be used to convert sorted loadings into
#'          \code{\link[=hyperSpec-class]{hyperSpec}} object.
#'
#'
#'
#'
#' @seealso More information at \code{\link[hyperSpec]{decomposition}}
#'
#' @import hyperSpec
#' @export
#' @examples
#'
#' sortLoadings(loadings)        # returns a matrix
#'
#' sortLoadings(loadings,sp)     # returns a hyperSpec object
#'
sortLoadings <- function(loadings, sp = NULL, PCA = FALSE, sort = TRUE){

    if (PCA & !is.null(sp)){ # flip
        ScoresTMP  <- getScores(hy2mat(sp), loadings)
        # ----------------------------------------------------------------------
        # Apverčiama, jei amplitudžių vidurkis neigiamas
#         meanSign     <- function(x){sign(mean(x))}
#         signCoefs    <- apply(ScoresTMP, MARGIN= 2, meanSign)

        signCoefs    <- sign(rowMeans(ScoresTMP))
        loadings     <- sweep(loadings, MARGIN= 1, signCoefs,`*`)

        # Normuojama
        maxSpInt     <- apply(loadings, MARGIN= 1, max)
        PCAvarimax2  <- sweep(loadings, MARGIN= 1, maxSpInt,`/`)

        # ======================================================================
    }

    if (sort == TRUE){
        # Rikiuojam iš eilės pagal matrcos eilučių maksimumo (y_max) vietą x ašy
        index.of.max <- apply(loadings, 1, which.max)
        OrderOfRows  <- order(index.of.max)

        # Viršūnių padėtis
        index.of.max <- index.of.max[OrderOfRows]

        # Matrix with Sorted components
        loadings <- loadings[OrderOfRows,]
        }

    if (is.null(sp)) {return(loadings)} else {

        # Komponentus (išrikiuotas) paverčiam į "hyperSpec"" objektą
        loadings <- decomposition(sp, loadings,
                                     scores = FALSE,
                                     label.spc = "Comp. spektrum",
                                     retain.columns = F)


        # Suteikiam pavadinimus komponantams
        PeakAt    <- make.unique(paste0(round(wl(loadings)[index.of.max]),
                                        "nm"),"_")

        # WARNING is needed, if variables with names are already present
        loadings$PeakAt        <- PeakAt
        loadings$kNames        <- paste0("max: ", PeakAt)
        loadings$order.of.rows <- OrderOfRows

        labels(loadings,'spc') <- labels(sp,'spc')

        return(loadings)
    }


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # # Komponentų amplitudes (išrikiuotas) paverčiam į "HyperSpec"" objektą
    # scores <- decomposition(Object, t(coef(NMF_data))[,OrderOfRows],
    #                            label.wavelength = "Komponentai",
    #                            label.spc        = "Amplitudė, a.u.")
    # colnames(scores$spc) <- paste0("k_", PeakAt)
    # ======================================================================
    #
    # # Print names of components
    # tbl_virsunes <- data.frame(Nr = 1:length(PeakAt), Padetis = PeakAt)
    # pander(t(tbl_virsunes), caption = "Komponento auksščiausios viršūnės padėtis")
    #
    # kNames    <- loadings$kNames
}

# Reconstruct spectra --------------------------------------------------------
#
#' [!] Reconstruct spectra from loadings and scores.
#'
#' Reconstruct spectra from loadings and scores (i.e. )
#'
#' @param loadings ??? loadings
#' @param scores ??? scores
#' @param sp original \code{hyperSpec} object. If \code{sp} is provided,
#' the result of this function will be the \code{sp} in which sp$spc
#' will be replaced with \code{reconstructed} spectra.
#'
#' @return \code{reconstructed <- scores \%*\% loadings}
#' @export
#'
#' @examples
#' function(loadings, scores)
#' function(loadings, scores, sp)
#'
getReconstructed  <-  function(loadings, scores, sp = NULL)
{
    reconstructed <- (hy2mat(scores)) %*% (hy2mat(loadings))
    if (class(sp)=="hyperSpec")   {
        sp$spc <- reconstructed; return(sp)} else  return(reconstructed)
}

#  ------------------------------------------------------------------------

#' [!] Find row numbers in scores matrix with outliers
#'
#' A row is treated as having an oultier if any
#' \href{autoscaled}{http://wiki.eigenvector.com/index.php?title=Advanced_Preprocessing:_Variable_Scaling#Autoscale}
#' value of that row is outside ±zScore (**grey** lines in figures below);
#'
#' @param scores ??? a matrix or a hyperSpec object of scores (component amplitudes)
#'        after decompositions to components.
#'
#' @param zScore ... Default zScore = 2.
#'
#' @return Vector of indices indicating rows which contain outliers.
#' @export
#'
#' @examples
whichOutlier <- function(scores, zScore = 2){
    SS <- scale(scores);
    iOutlier <- which(apply({(SS < -zScore) | (SS > zScore)},1,any))
    return(iOutlier)
}

#  ------------------------------------------------------------------------
